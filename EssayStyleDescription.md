#Understanding MinecraftForge 

Try and imagine the number of people in the world that play actively video games today. An industrial study made by 'Spil Games'<sup>1</sup> in 2013 reports that "The total number of people around the globe who play [video] games is expected to surpass 1.2 billion by the end of 2013".<sup>2</sup> At the time, that would have been around 17% of the world population. The same study also reports that “…more than 44% of [that] population play online games.” Many software developers are not aware of these numbers and consequently do not realize how big an influence the gaming industry has on modern society. With these numbers in mind, we introduce the reader to Minecraft, a game written exclusively in Java, which has sold over 21 million copies<sup>3</sup> making it the best-selling PC game to date.<sup>4</sup> The game was released in 2009 by Swedish games studio Mojang AB.<sup>5</sup> To further justify the popularity of Minecraft, celebrity developer Nathan Adams of Minecraft boasts through social media: “There are currently over 998,000 people playing Minecraft right now at this moment. It is not even remotely close to being a peak time.”<sup>6</sup> This drives us to ask the question, why is Minecraft so popular? Simply put, it is because the game grants full creative freedom to its players. It is an open world concept sandbox game. In other words, a player is free to do whatever they want with the environment around them. Sandbox games are appealing to a lot of people because they nurture imagination and creativity. More specifically, Minecraft offers its players the freedom to explore, learn, and build constructions out of textured cubes in a 3D procedurally generated world. For example, consider a player wishing to build a house. The player would first need to gather the resources (cubes) from the world and then manually place them down into the shape of a building. Minecraft does not restrict the player to any blueprints. In other words, the types and sizes of houses a player can choose is not determined by the game. One individual tasked to build a house may come up with a design that is different than a house made by another individual with the same task. Additionally, users are free to spend as little or as much time as they want playing the game; there is little time commitment required to have fun on Minecraft. Finally, players may choose to play the game alone by installing the Minecraft client, or play with others by connecting the client to a multiplayer Minecraft server. However despite all this room for creativity unique to the genre, what a player can do is limited by the inherent mechanics of the game. Things like the graphics, physics, content and user interface are all limitations of Minecraft. To give a few concrete examples, these would include the player's inability to walk on water or lava, grass cubes always generating with the same shade of green, and creatures producing the same sounds. Thus we reason with the reader that there must be another reason why Minecraft has been met with such success. The pivotal reason that explains why Minecraft has met such success is captured in an article by CTV News: “What … makes Minecraft so exciting is that the game can be – and regularly is – modified by players.”<sup>7</sup>

##1. Minecraft Forge

One of the main appeals of Minecraft is that users can download community created content known as mods. Those mods – short for modifications – are add-ons to the game that implement new features or modify existing features in the game. The range of various types of mods that exist is vast. There are so many types of different mods that these mods are not aggregated on a single domain; they are hosted across a multitude of different websites. To give a concrete example, the most downloaded pack of mods to date hosted by Curse Inc, a well known online gaming portal, is a pack called “Tinker’s Construct”.<sup>8</sup> By downloading and adding this mod pack to Minecraft, a player is given access to a variety of new tools, weapons and armors. When added to the game, these new items come in addition to the pre-existing ones found in classic Minecraft. Interestingly enough, the original creators of the game did anticipate that their game could or would become modifiable; the facilitation of mods is not inherently supported by Minecraft. During Minecraft’s infancy, skilled independent developers discovered that Minecraft’s code, found in the massive Minecraft.jar file, could be easily decompiled. This resulted in the pioneering of the first simple mods for the game. Despite being easily decompiled, Minecraft’s code was obfuscated and difficult for humans to interpret, which made mod creation very difficult for the average developer. This complication was removed with the introduction of the Mod Coder Pack (or MCP) created by Michael Stoyke.<sup>9</sup> MCP made modding (the act of creating a mod) easier for developers by applying meaningful names to the obfuscated code, allowing developers to more easily modify the base files to create mods. At the time, there existed a program called the ModLoader, developed by Minecraft user Risugami<sup>10</sup>, which worked to manage compatibility issues between simple mods. However, complications arose when users tried to load complex mods, which edit many of the same Minecraft files, into their game instance. This leads us to introduce the project we've analyzed throughout this semester. An article documenting the history of Minecraft modding describes nicely: “Seeing that their mods couldn’t be used together, the creators of several major mods launched a new project. They would call it Minecraft Forge.”<sup>11</sup> The dawning of Minecraft Forge, an open source tool built on top of MCP and ModLoader, revolutionized Minecraft’s already vibrant and rapidly growing modding community. Minecraft Forge (or Forge) is an improvement of its predecessor the ModLoader, as well as standardizes the way developers can create mods by exposing an application programming interface (Minecraft Forge API) for standardized mod creation. Through the use of the API, mod developers can be assured that mod incompatibilities will be handled by Forge. Minecraft Forge is a mod layer built on top of Minecraft, meaning it can be thought of as an (unsupported) plugin. The mod layer acts the intermediate adapter between mods created through its API and the game. This relationship is depicted in a simple manner below:

![alt tag](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/mod%20layer.png)

Both players and developers can download Forge and use it to reduce (or eliminate completely) existing mod incompatibilities. Minecraft Forge is so widely used by the modding community that the majority of mods which exist are created using the Forge API. Consequently, a player who wants to use mods will need to have the Minecraft Forge client installed on their system. To understand how to contribute to the Minecraft Forge project, we have organized this paper into sections. We first outline the external entities that Forge is dependent on. This is followed by a discussion on how Minecraft Forge is coupled together with Minecraft. Next, we discuss how Minecraft Forge provides its three primary functional capabilities: facilitate the means by which developers can create mods, provide the capability of configuring specific features of mods at runtime, and inject Minecraft with the ability to support mods. We conclude by describing how Minecraft and Minecraft Forge are deployed onto a client and a server machine at runtime.

##2. Minecraft Forge and its External Entities

Forge is a system which depends on few external entities. Before further discussion, we provide a diagram denoting the external entities with which Forge must interact with to function.

![alt tag](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/M4%20Context%20Diagram%20.png)

The reader may immediately notice that Forge does not depend on many external entities. This is because Forge's primary functionality is to act as a mod layer for Minecraft. The notion of a mod-layer is difficult to describe. We loosely defined this as an unsupported plugin in the introduction, however we implore the reader to think of a mod layer as a mod which enables the use of other mods. In other words, Forge is a mod of Minecraft that allows other mods to be used in Minecraft. Again, the systems lack of external dependencies is explained by the intimate relationship it has with Minecraft. Note that Forge does not interact directly with any servers or databases because these are all functionalities implemented by Minecraft. More discussion on how Minecraft Forge relates to Minecraft is given in section 4.

####2.1 Responsibilities of External Entities

Minecraft Forge is used by two types of users. The first group of users are mod developers. These developers require a functional knowledge of the Java programming language in order to develop mods. Forge enables the creation of mods through its APIs which mod developers must use to implement their mods. The APIs exposed by Forge are utilized in the mods created by mod developers to manipulate the Minecraft game state. The second group of users which depend on Minecraft Forge are players who use Forge to play mod supported Minecraft. How a player uses the system is very simple: install Forge (a process which is well documented online) and copy the mods they wish to use into the 'mods' directory (created by Forge upon installation). At launch time, Forge will analyze the JAR files (mods) found in the 'mods' directory in order to resolve compatibility issues between the mods and remove any redundancies within their contents. Forge identifies mods by parsing through the directory for annotations. The possible kinds of annotations are discussed in section 6.1. 

Forge uses Gradle (an open sourced build automation tool) as its build system of choice and this is realized through ForgeGradle.ForgeGradle is a Gradle plugin designed to allow developers to easily update their development environment and for them to easily build their Minecraft mods. In order for project to take advantage of the many features offered by Gradle, the ForgeGradle plugin was created. ForgeGradle is used by Forge developers because Gradle provides: "Cleaner code, Cleaner work spaces, Separation of Mod code from Minecraft Code, Dependency Management, Automated deployment, OS independence".<sup>12</sup> ForgeGradle allows developers to update their workspace to the latest version of Forge with ease. To update their environment, developers will only need to run a few simple commands and ForgeGradle will perform its job of updating Forge to the latest version. <sup>13</sup> ForgeGradle is actively maintained and has evolved the ability for mod developers to build the mods they've created. It is a very simple build system that works through the usage of Recipes. A Recipe is defined as: a set of specific instructions that collectively accomplish a given task. Through the use of these Recipes, Forge is able to specify which files it wants ForgeGradle to build. A nearly comprehensive list of pre-defined Recipes can be found in the ForgeGradle documentation.<sup>14</sup>

The second external entity upon which Minecraft Forge depends is FernFlower. Because Minecraft source code is not open sourced, the only code available to the general public is the pre-compiled code found in the Minecraft JAR files. FernFlower is a working analytical Java decompiler that is able to reverse engineer Java byte code into human readable source code. It is through the use of Fernflower that Forge was able to create the APIs for manipulating Minecraft game logic. We believe that more respect needs to be given to the FernFlower endeavor, as most developers take this decompilation process for granted. We note that the decompiled code created by Fernflower will have equivalent logic to the original source code but will not necessarily be the exact same. This is because at each step of compilation of source code, some metadata is lost. The idea behind this can be explained through a humorous analogy: "It is difficult to make a cow out of hamburgers".<sup>15</sup> While this is not exactly the same with byte code, we hope the reader understands our attempt at drawing the parallel. In conclusion, FernFlower is used by the system to reverse engineer the code contained in Minecraft's JAR files. The system imports Minecraft packages and classes from the decompiled code in order to use it for its own goals.

The last external entity is Minecraft, which was not only vital to the creation of Forge but is the entire reason our system still exists. Forge is a mod layer for Minecraft and because of this it has a very intimate (one sided) relationship with Minecraft's code. Minecraft exposes its inner workings through its compiled byte code found in the massive Minecraft JAR file. Forge is able to capitalize on this exposure by decompiling the contained code, and refurbishing the code for Forge's purposes. This is how Forge was able to develop a comprehensive API containing methods for all sorts of game state manipulation. Thus through the decompilation and importing of the code released by Minecraft, Forge is able to offer its users the ability to modify the game however they please. We understand that the concept of manipulating code seems rather illegal. Fear not, for the end user license agreement released by Mojang allows for this type of activity, as we explain in the next section.

##3. Legality Issues with Minecraft Forge

The end user license agreement for Minecraft can be found on the official Mojang website.<sup>16</sup> The EULA written by Mojang is very easy to read and very cute in the way it is worded. The text conveys using very simple vocabulary one simple message: as long as the user does not redistribute or resell the game, Mojang will be happy. It goes without saying that the usual terms associated with video games are also addressed, such as liability issues, piracy statements, and ownership. We decided to include this section to address the legality of Minecraft Forge. The Minecraft EULA actually uniquely addresses the act of creating "Mods" which Mojang defines as "something original that you or someone else created that doesn't contain a substantial part of our copyrightable code or content".<sup>16</sup> It is very interesting to note that the EULA even specifically states: "....we really encourage you to do cool stuff". Should the reader be interested in learning more about the terms, they are free to read about it on the company's website. Our main goal is just to inform the reader that should they consider contributing to Minecraft Forge, they will not have to worry about breaking any laws.

##4. How Minecraft Forge relates to Minecraft

From an evolutionary standpoint, Minecraft Forge is very closely coupled to Minecraft. That is to say, when Mojang releases a new patch or a new version of Minecraft altogether, Minecraft Forge needs evolve by accounting for these changes in order to stay functional. Consequently, a mod which worked for the previous version of Forge may no longer work in the new version and will need to be updated by the mod's developer to be supported by the updated Forge version. To reiterate, Minecraft Forge needs to update to support newer versions of Minecraft. A mod built through Forge will also need its developer to update it if the mod has become incompatible with the latest version of Minecraft Forge. However we state here that it is not always necessary to update Minecraft Forge when there is an update for Minecraft. When there is a big update for Minecraft, for example, from v1.7 to v1.8, then there is a necessity for Minecraft Forge to update. This is usually due to drastic changes to existing code in Minecraft or new code not yet accounted for by Forge. If the Minecraft update only introduces minor changes, for example, from v1.8.1 to v1.8.2, then there is either no need for Minecraft Forge to update, or very little changes that need to be performed. Regardless of the update, it is always up to the Forge development team to determine whether a new Forge release is necessary.

Minecraft Forge will always need to evolve following Minecraft since it is evolutionarily coupled to Minecraft. We mentioned briefly that any changes done to the Forge API will also force all mods that were written with the previous API to evolve. A mod that does not update along with the Forge API will no longer be usable in the newer versions of Minecraft. We later discuss in section 6.1 how a mod developer will use the Java nnotations specified in the API to develop mods. These annotations allow developers to mark the components of their mods (classes and methods) to use MinecraftForge like a framework. Consequently, any changes to the MinecraftForge API, particularly the annotations, will likely cause a lot of refactoring work required by mod developers. We can see that if this API framework is well-designed for extensibility then this would place less stress on developers to keep their mods functional in newer releases of Forge. In a more recent update<sup>17</sup>, MinecraftForge has successfully merged some of its older, classical annotations together. The update makes it evident that there is an ongoing trend for less specific, more general annotations in Forge. These new annotations that were introduced have replaced some of the traditional annotations which were commonly used in the past. As a concrete example, there used to exist three annotations, `FMLPreinitializationEvent`, `FMLInitializationEvent`, `FMLPostInitializationEvent` which have now all been replaced by the annotation `@EventHandler`. Any method tagged with `@EventHandler` will now need to take a parameter as input `FMLEvent` corresponding to one of the three phases mentioned previously. It is through these measures that Forge is trying to reduce the amount of change mod developers will need to perform to keep their mods supportable by Forge. This kind of design decision made by the Forge development team is an effort to promote a more extensible system.

##5. How patching is performed

To explain how Minecraft Forge applies changes to Minecraft for mod support, we first discuss the most integral part of the Forge installation process. There are two types of installations a player of Minecraft can perform: a client installation or a server installation. A server installation is only required if the player wishes to become the host of a Minecraft server, to which other players may connect to. Again, there are two types of Minecraft Forge installations (client or server) that a user can perform. A key component of the installation process of Forge is the application of diff files for patching. During the installation process of Forge, there is a Patch Manager dedicated to applying these patch files to Minecraft. Following the patching process, a patched (or modded) version of Minecraft is made. We will now refer to this as the Forge-patched version. A Forge-patched version of Minecraft will use the Forge implementation of certain methods throughout the games loading and regular execution. The methods used in a Forge-patched client or Forge-patched server are modified version of its classic (vanilla) counterpart. We show below a general activity diagram of the patching process below with a concrete example to follow.

![Image](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/Patching.png)

We use the method `beginMinecraftLoading` of class `IFMLClientHandler`<sup>18</sup> as our example. By examining the appropriate patch file, we can see a method call in `minecraft/net/minecraft/client/Minecraft.java` is replaced with `net.minecraftforge.fml.client.FMLClientHandler.instance().beginMinecraftLoading(this, this.field_110449_ao, this.field_110451_am)`<sup>19</sup>. We can see from this example that the method is replaced by the patch. Consequently, now when the Minecraft client is launched, it will use this replacement method instead of its own. When a user launches a Forge-patched Minecraft client, this client now has Forge's version of `beginMinecraftLoading` which incorporates (on top of the vanilla method behavior) the discovery and loading of mods from the filesystem into main memory. The discovery and loading of mods is very interesting and this is discussed in the section that follows.

##6. The functional capabilities of Minecraft Forge

We describe in this section three primary functionalities that Minecraft Forge provides to its users.

#####6.1 How Minecraft Forge Facilitates Mod Creation
One of the main features unique to Forge is that it standardizes the creation of mods. The standardization of mod creation is the reason behind how Minecraft Forge is able to resolve dependencies and compatibility issues between mods. We first describe how Forge works like a framework for mod developers. Forge provides a set of annotations along with its APIs to a mod developer. The developer will use the annotations to mark the different components of the mod they are building, namely the classes and methods they will use. These annotations make a mod recognizable by Forge and consequentially injectable into Minecraft. The API provided by Forge gives the mod developer access to functions which they can use to manipulate Minecraft game state to their desire. For example, the API may be used to manipulate enum types used by Minecraft or to add new complex elements that aggregate primitive elements. As an example, a potential mod could introduce a new 'biome element' to the game. This 'biome element' would have to consist of the basic elements 'blocks', 'items' and 'plants' as defined by Minecraft. To introduce this element, a user will need to define the element through their own classes, mark their classes with the provided annotations and finally register them into Minecraft through the provided API. The annotations mentioned above are in the package `net.minecraftforge.fml.common` and the API mentioned above are contained in both `net.minecraftforge.common` and `net.minecraftforge.fml.common` packages. A mod developed using Forge's specifications will allow Forge to identify the mod when it scans the 'mods' directory. The process of scanning the filesystem is discussed in section 6.3. The module responsible for loading the discovered mods is the Forge Mod Loader(or FML) package. The Forge Mod Loader makes use of the powerful Java Reflections API to statically parse the classes in the directory for any `@Mod` annotation. Generalized relationships between Forge, Minecraft, and the mods created through Forge are shown in the following diagram:

![image3-1](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/Mod_1.png)

In order to develop a mod using the MinecraftForge API, a developer will need to use the aforementioned annotations. The developer would mark the components in their mod, be they classes or methods, to enable Forge's Mod Loader to recognize them at launch time. Here are the following types of annotations provided by Forge:

- `@Mod(modid=String, name=String, version=String)`: marking the main class of a mod with this annotation tells Forge that this class defines the base class of a mod to be loaded by the Forge Mod Loader at runtime.
- `@Instance`: used to identify the mod instance.
- `@SidedProxy(clientSide=String, serverSide=String)`: used to register the pointers to a proxy for client and and a proxy server. Proxies are used to load specific code pertaining to the client or to the server. For example, if a mod developer wants to write a GUI component in his mod for the client side, then they will put the code in the file indicated by the clientSide annotation parameter.
- `@EventHandler`: used to indicate the implementations of event handlers for life cycle events. Life cycle events are events which occur during the loading phase of a mod. The events `FMLInitializationEvent`, `FMLPostInitializationEvent` and `FMLPreInitializationEvent` occur while the game is in the loading phase. `FMLServerAboutToStartEvent`, `FMLServerStartingEvent`, `FMLServerStartedEvent`, `FMLServerStoppingEvent` and `FMLServerStoppedEvent` occur when Minecraft is in multiplayer mode. More descriptions about these events can found in [Mod.java](https://github.com/MinecraftForge/MinecraftForge/blob/master/src/main/java/net/minecraftforge/fml/common/Mod.java) under *MinecraftForge/src/main/java/net/minecraftforge/fml/common/* along with a description of what a developer can choose to do at each stage in the life cycle.
- `@Metadata`, `@InstanceFactory`, `@CustomProperty`: used to indicate optional features. These are not very interesting or particularly useful to the readers understanding of the system so we'll refrain from explaining their uses here. 

Within the FML module, there is a specific class called a `Loader`. These annotations are required for the `Loader` to interpret how it should load a given mod. The Loader splits the loading process into four phases: construction, pre-initialization, initialization, post-initialization. We show example code of a "dummy" mod below to explain what behavior could be defined by a developer at each phase. 

*DISCLAIMER: The code below is a sample mod which does nothing. It is only intended to be used in this document.*

```java
/*Import necessary classes from Minecraft and MinecraftForge. The imports indicate which classes the developer wants to use from Minecraft and which APIs from Forge will be used in this mode.
*The import statements are dependent on what the mod creator wants to add to the game, and which annotations they want to use.
*They are omitted in this example.*/

//The main class of a mod is marked with the @Mod annotation
@Mod(modid="myMod", name="MyMod", version="0.0.0")//put name, id and version of the mod here.
public class myMod {

    @Instance(value="myMod")//indicates to FML to create an instance of the mod.
    public static myMod instance;

    //tells Forge where to find the files containing proxy for client or server. They will be loaded during the construction phase.
    @SidedProxy(clientSide="mod.myMod.clientProxy", serverSide="mod.myMod.serverProxy")

    @EventHandler
    public void preInit(FMLPreInitializationEvent event){
        //read configuration, create blocks, items, etc. Register new elements with GameRegistry.
    }

    @EventHandler
    public void Init(FMLInitializationEvent event){
        //setup this mod. Build structures, register recipes.
    }

    @EventHandler
    public void postInit(FMLPostInitializationEvent event){
        //handle interaction with other mods, complete setup.
    }
}
```

Using the `@SidedProxy` annotation, the mod developer will indicate the location of files for both a server and a client proxy. With the `@EventHandler`, the mod developer can define their own event handler for each phase of the mod loading process. For example, a mod developer wishing to write a mod which adds content to Minecraft will define a method tagged with an `EventHandler` for the `FMLPreInitialization` phase. From within this method, they can call `MinecraftForge.fml.common.registry.GameRegistry()`.The loading process for the mentioned mod will then execute in the following manner:

![image3-2](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/M2-w2.png)


We can now comfortably present the general structure of a mod:

![mod structure](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/Mod%20Structure.png)

A mod consists of a main class, a client proxy, a server proxy and a set of helper classes. The main class contains the location of proxies, and can call these helper classes. When the mod is complete and ready to be shipped, it is built into a JAR file. A mod developer will usually share their creation on the web for greater good of the community, however sharing is not enforced by anyone; mod developers can keep their creations to themselves. Should a mod be downloaded by a member of the community, they can now copy it into their local 'mods' directory and Forge will do the rest. Next we discuss the ability to configure loaded mods at run time through the GUI of the Forge client.

#####6.2 How a Mod can be Dynamically Configured

A reader may be curious whether mods are binary (present or not present) for a specific game instance. Minecraft Forge enables its users to configure the mods (that have already been loaded into the game) at run-time. What this means is if a user does not feel like playing with a particular mod, they can simply deactivate it through the GUI. This type of behavior is native to Forge and does not need to be implemented by the mod developer. We can see that although it's useful to be able to deactivate mods at runtime, this is still somewhat limiting because the player only has the options of on or off. Forge overcomes this limitation by allowing mod developers to make certain aspects of their mods analog with multiple states. The mod developer will need to account for the different states a mod can take, and implement these states according to Forge's specification. If done correctly, Forge can recognize that the mod developer has created a configurable mod. The player now has the ability to configure the mod by interacting with the GUI provided by Forge. They can do so through the the main menu where there is now a new button named "Mods" which is not found in vanilla clients. Below is a side by side view between the main screen of a classic Minecraft client and a Forge-patched Minecraft Client.

![Mods Button](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/classicMinecraft.JPG)

This button gives access to the configuration menu, which will list all the mods that are configurable. We now turn to discuss how the configurable mod was loaded into the client. During the loading process of a mod, the `Loader` class described in section 6.1 will load the mod from disk into main memory. The main memory element representing the mod is called a `ModContainer`. Again, this element is put together during the construction phase. Upon selecting a mod in the GUI, the player is presented with the list of possible configurations that can be made to that mod. A developer that chooses to implement a configurable mod will have various types of configuration options. There are 6 categories of configurations defined by Forge: Boolean, integers, strings, double, lists and sliders. For example, we've created a simple mod which creates a creature named Steve. We could add a configuration option of type String and associate it with the creature's class. A player with our mod could then change the String value to whatever they want, such that when they play the game the name will be whatever they assigned.

The entity responsible for applying the configurations made to the in-memory `ModContainer` is the `FMLCommonHandler`, which is responsible for many things in Forge. One of its key responsibilities is to handle all game state changes that may occur during the normal execution of a client or server. Thus when a user invokes a configuration change through the GUI, the listeners of the `FMLClient` will tell the `FMLCommonHandler` to apply the configuration to the appropriate `ModContainer`.

![Concern2part2](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/functionalviewconcern2part2.png)

Allowing dynamic mod configuration is necessary as an end-user requirement to provide players with a less rigid, more flexible system. Providing a Minecraft client or a Minecraft server capable of mod support is the last functional capability we describe in this document.

#####6.3 Enabling Mod Support in Minecraft

Vanilla Minecraft allows two options to its players: singleplayer or online multiplayer. A player will need to connect to an active Minecraft server in order to play in a multiplayer setting. Minecraft Forge supports mods for both the client and the server. When a mod is written, the developer is required to define the mod's behavior in a client and the mod's behavior in a server. If the mod is written exclusively for one of them, then the behavior implementation for the other is left empty. We reintroduce the process covered in Section 5: patches are applied to classic Minecraft at installation (of a Forge client or a Forge server) time. After patching has been completed, some methods used in Minecraft are replaced by the Forge implementations.

The procedure of discovering and injecting mods into Minecraft follow the same general process for both client and server. Both of them rely on the `Loader` class to perform the following actions: identify mods contained in the 'mods' directory, inject the mods into Minecraft (following the phases mentioned in Section 6.1), and instantiate the objects required by each mod. So after this process is completed during a Forge client or server launch, the identified mods are fully incorporated into the instance. We digress here to explain that both Forge client and server contain a class which implement an `IFMLSidedHandler` interface that defines a set of operations which both sides (client and server) need to perform.

For the client side, `FMLClientHandler` implements the interface and will handle all the loading required on the client side. The patching process described earlier forces the Minecraft client classes to use the `FMLClientHandler` to create an instance of Minecraft instead of its original procedure. Should the reader not remember, the process of replacing Minecraft code with Forge code was explained in Section 5. The following diagram is meant to depict abstract relationships between the entities involved in hopes of promoting our reader's understanding.

![Client side](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/ClientStart.class.png)

Similarly on the server side, `FMLServerHandler` implements the server sided behavior of the interface. The patching forces the MinecraftServer classes imported from Minecraft to use the `FMLCommonHandler` that we mentioned in Section 6.2. We discuss here another responsibility of `FMLCommonHandler`, which is to  handle the different states that a server can enter. The following diagram attempts to draw a parallel to the client abstraction above.

![Server side](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/ServerStart.class.png)

In both cases, a call to the method `beginLoading(IFMLSidedHandler)` to `FMLCommonHandler` is made. This method is responsible for telling the `FMLCommonHandler` which type (client or server) of launch it will be performing. We mention this here because the `FMLCommonHandler` is involved in setting up the network used by the client if they wish to enter a multiplayer setting. We discuss briefly in section 7 the establishing of connections between server and client. We now proceed to detail more specifically how discovery and injection are done to client and to a server by beginning first with the client. 

The client launch is split into two phases: when Minecraft begins loading and has finished loading. The ultimate goal is to have an active client that incorporates mods. Section 5.1 explains how a developer can use the Forge API methods available in the `net.minecraftforge.common` and `net.minecraftforge.fml.common` when making their mods. The unlableled arrows in the following diagram are meant to represent the general API calls that would have been included into any mod. They represent calls which can be made at the different phases: discovery, construction, preinitialization, initialization, postinitialization. Here we introduce the discovery phase to the pipeline described in 6.1. 

The `Loader` class delegates the responsibility of discovering mods from the filesystem to another class `ModDiscoverer`. During this phase `ModDiscoverer` opens the 'mods' directory and parses it for all occurrences of the `@Mod` annotation. A list of the classes tagged with `@Mod` is built during this discovery phase and returned to the `Loader`. The `Loader` constructs a `ModContainer` instance for each identified mod respectively. The `ModContainer` is a format which is understandable by Forge. We opted to explain the discovery process in text in order not to obfuscate the diagram below.

![clientgeneralInit](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/generalInitialization1.sequence.png)

Similar to the client launching, a server launch is also split into two phases: when the server begins loading and when the server finishes loading. The process of discovering, constructing and injecting mods into the server is identical to the client. The only difference are the lower level details of implementation which we do not describe as they are not architecturally significant. We omit the API calls as they are similar to the client diagram above and would be redundant in nature.

![servergeneralInit](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%202/Functional%20View/images/ServerStartSequence.sequence.png)

##7. The Architecture of Forge

The reader may already realize that Minecraft abides by a client-server architectural style. It should come naturally that this client-server architecture also applies to the system in question as it is built to go on top of Minecraft. We show here how Forge clients interact with a server at a high level.

![Diagram for a client-server coms](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/clientserver.png)

The following diagram is used to further justify how Minecraft Forge also abides by a client-server architecture. Three of the elements here were briefly introduced in the previous section: the interface `IFMLSidedHandler` implemented by the client sided handler and server sided handler. These classes are found in the FML module of the system. There is another module in Forge responsible for networking which we've abstracted in the diagram and named Network. The elements found in the Network abstraction import many classes and methods from Minecraft Network while implementing their own behavior to go on top. The dependencies between elements inside FML and Network are complex and are abstracted by the doubly-sided arrow between Network and FML. We refrain from showing the more specific interactions, as they get quite complicated, and invite the reader to examine the classes if they are interested.

![Diagram for client-server](https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/betterClientServer.png)

The goal here was to try and provide the reader with a general idea of which entities are involved in the network communications implemented by Forge in order to support our claim that Forge follows a client-server architectural style. Hopefully the reader now has an improved understanding of Minecraft Forge along with the goals it seeks to accomplish. One more concept relating to our system is still in need of an explanation: how are Minecraft and Forge deployed onto a users machine?

##8. Deploying the System

The deployment of Minecraft and Forge onto a users system are separated into two types: client machine and server machine. We have chosen to address these two as separate machines, however we inform the reader that the client and server may be installed on the same machine. We explain here how the high-level elements we have mentioned throughout the paper are deployed. The following diagram shows where the most important internal elements of Minecraft and Forge are placed onto the hardware.

*Note: The diagram separates the components of Minecraft and Forge into smaller artifacts to provide a more comprehensive view of how the components interact with one another and where they are stored. For clarity, artifacts labelled orange are found with Minecraft and similarly green artifacts with Minecraft Forge.

![alt] (https://github.com/McGillCOMP529F2015/CraftMods/blob/master/Milestone%204/Images/M4%20Deployment%20.png)

There are two types of hardware machines required for multiplayer gameplay: a server and a client machine. No special hardware is needed to play Minecraft. Minecraft's inherent architecture is client-server, and consequently Minecraft Forge has adopted the same architecture. We point out that the set of Forge components on both machines are nearly identical. The components are very similar because the patching process used by Forge in both types of installations are very similar. Additionally, the discovery, loading and injection of mods in both a Minecraft client and a Minecraft server follow nearly the same process and thus require similar files with very few notable differences.

#####8.1 Artifact Details and Placement Rationale

Any JAR file representing a mod is stored in stable storage for both the client and the server machines because a mod will contain code written for both the client and server. It will ship with both client-side and server-side features implemented, however only client-side code is executed on a client with the same idea applying to the server. A Forge client who wishes to join a Forge server will need to possess all mods that the server is currently hosting in order to establish a connection.
Patch files are also stored in secondary storage for any client and server machines. The set of patch files on each machine, however, will differ between the two. During the patching process, patch files on the server side will patch the Minecraft server implementation. Similarly, patch files on the client side will patch the Minecraft client implementation. The PatchManager artifact is responsible for handling this process on both sides.

The protocol by which the server and client communicate to each other is implemented by Minecraft thereby allowing network details to be abstracted away from the user. However, because Minecraft is not open sourced, our research did not to encompass understanding how the decompiled code from Minecraft implemented networking.

The primary difference between servers and clients is that a server will store its Minecraft "World State" on disk. This artifact keeps a centralized master state of the game in order to prevent conflicting states between the clients which may connect to the server at different times. 

#####8.2 Hardware and Networking Hosting Requirements

Because Forge can be thought of as a plugin to Minecraft, most of the hardware and networking requirements are set by Minecraft rather than Forge. The requirements to run Minecraft can be found on the official Mojang website.<sup>20</sup> In order to run Minecraft, a machine will require at least: 

* at least 40mb of disk space available.
* an Intel Pentium D or AMD Athlon 64 (K8) 2.6 GHz CPU
* 2GB RAM
* an Intel HD Graphics for the GPU.(7XXX) as GPU

The inclusion of mods which are downloaded and stored onto disk will inevitably increase the disk space requirement. The magnitude of disk space required is unpredictable since different users can use a varying number of mods. The 10 most popular mods hosted on Curse<sup>21</sup> are no more than 10MB each. It is fair to assume that the size of most other mods will land around this number or lower. A last important point to mention is that the disk space requirement for Minecraft is very unique. A Minecraft server will save the entire world state depending on how much of the world you have explored. The world in Minecraft is infinite and does not have any boundaries. We mention this here because these map files will add up, and could hypothetically require many gigabytes of storage space. This idea behind disk space requirement may also apply to the mods currently running in the game instance.

##9. Conclusive Remarks

Minecraft Forge has clearly been a pivotal component to the success Minecraft has witnessed over the last few years. The endeavor grants developers the ability to concretize their imagination into virtual reality, enabling players to overcome the limitations inherent to vanilla Minecraft. The act of making modifications for Minecraft has been so well received by the game's creators that in fact, "... Mojang intend[s] to gift [Minecraft's] future to [its] modders and tinkerers."<sup>22</sup> For a company to make such a statement, we end with utmost confidence that the future of Minecraft, truly, belongs to its modders. 

##10. Biography of the Authors

This document was developed by four undergraduate students for a Software Architecture course offered by McGill University.

Henry Lin is a student majoring in Software Engineering at McGill University. Prior to taking this course, Henry had no workable knowledge regarding software architecture and had only taken one course on Software Design. Henry gained humble experience with rural building architecture when he and his father built a quonset and two-story home on their acreage back in Saskatchewan. Henry aspires to become a qualified software developer.

Brian Zhu is a student majoring in Computer Science with a minor in Management at McGill University. Prior to taking this course, Brian has been worked at Workday as a software developer intern and at EquipOne (an e-commerce startup) as a marketing intern. He has also has also worked on several software projects such as Medieval Warfare (a turn-based strategy game), a Flappy Bird clone, and a Tower Defense game.

Zhenyu Wang is a student majoring in Computer Science - Computer Games. A hardcore gamer interested in all game genres. Zhenyu had taken a course on Software Design and developed a game for a project of another course.

Bruno Da Rosa Miranda is a student majoring in Computer Science at McGill University.  He was also involved in the development of an open-source web-accessible database for the Montreal Neurological Institute in the summer of 2015. He has taken a course of software architeture and a course modern computer games.

##11. Sources

1. http://www.spilgames.com/about-us/
2. http://auth-83051f68-ec6c-44e0-afe5-bd8902acff57.cdn.spilcloud.com/v1/archives/1384952861.25_State_of_Gaming_2013_US_FINAL.pdf
3. https://minecraft.net/stats
4. http://teehunter.com/2014/09/top-10-best-selling-pc-games/
5. https://mojang.com/about/
6. https://twitter.com/Dinnerbone/status/553556703992889345
7. http://www.ctvnews.ca/lifestyle/minecraft-why-are-kids-and-educators-so-crazy-for-it-1.2006975
8. http://www.curse.com/mc-mods/minecraft?filter-project-game-version=&filter-project-sort=5
9. http://minecraft.gamepedia.com/Michael_Stoyke
10. http://file-minecraft.com/risugami-modloader/
11. https://www.packtpub.com/books/content/brief-history-minecraft-modding
12. http://www.minecraftforge.net/forum/index.php/topic,15095.0.html
13. http://www.minecraftforge.net/forum/index.php?topic=14048.0#post_update_forgegradle
14. http://forgegradle.readthedocs.org/en/FG_1.2/cookbook/
15. http://programmers.stackexchange.com/questions/229761/why-cant-native-machine-code-be-easily-decompiled
16. https://account.mojang.com/documents/minecraft_eula
17. http://www.minecraftforge.net/wiki/Basic_Modding
18. https://github.com/MinecraftForge/MinecraftForge/blob/767d7339485258545b9e674f7ddb8ac4a348c857/src/main/java/net/minecraftforge/fml/client/FMLClientHandler.java
19. https://github.com/MinecraftForge/MinecraftForge/blob/90829a316439efe7ddeb8f03b030e00366d8d03c/patches/minecraft/net/minecraft/client/Minecraft.java.patch#L16
20. https://help.mojang.com/customer/en/portal/articles/325948-minecraft-system-requirements
21. http://www.curse.com/mc-mods/minecraft?filter-project-game-version=&filter-project-sort=2
22. http://www.pcgamer.com/the-future-of-minecraft/


